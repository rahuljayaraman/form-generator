module DynamicModel
  def initialize_dynamic_model
    model_name = self.source_name.attribute
    klass_name = "#{model_name}#{self.user.id}".classify
    object = self

    klass = Class.new do
      include Mongoid::Document
      include Mongoid::Timestamps
      include ActiveModel::Validations
      include Mongoid::MultiParameterAttributes

      store_in collection: self.collection_name
      field_names = []
      object.source_attributes.each do |m|
        field m.field_name.attribute.to_sym, type: object.class.mapping[m.field_type]
        attr_accessible m.field_name.attribute.to_sym
      end
      #All dynamic models belong to user
      belongs_to :user, inverse_class_name: klass_name

      #Search
      def self.search attr, belongs_to = nil
        search = self
        # From to filter for created_at
        unless attr[:created_from].blank? or attr[:created_to].blank?
          search = search.where(created_at: {'$gte' => attr[:created_from], '$lt' => attr[:created_to]})
        end
        attr.delete :created_from
        attr.delete :created_to

        # Look for model's own attributes
        attr.keys.each do |field|
          search = search.where(field.to_sym => attr[field.to_sym]) unless attr[field.to_sym].blank?
        end

        # Look for related belongs_to attributes. This field is generated by source search_models
        if belongs_to

          # Look for user attributes if present
          if belongs_to["user"]
            return [] if belongs_to["user"].empty?
            field_name =  'user_id'
            search = search.where(field_name.to_sym.in => belongs_to["user"]) if belongs_to["user"].count > 0
            belongs_to.delete "user"
          end

          belongs_to.keys.each do |source_id|
            if belongs_to[source_id]
              return [] if belongs_to[source_id].empty?
              source = Source.find(source_id)
              field_name = source.collection_name_helper.singularize + '_id'
              search = search.where(field_name.to_sym.in => belongs_to[source_id]) if belongs_to[source_id].count > 0
            end
          end
        end
        search.all
      end

      #Relationships
      object.has_manies.each do |h|
        object_model_name = h.source_name.attribute
        object_klass_name = "#{object_model_name}#{object.user.id}".classify
        has_many object_klass_name.tableize.to_sym, inverse_of: klass_name.underscore.to_sym, inverse_class_name: klass_name
        attr_field = object_klass_name.underscore + "_ids"
        attr_accessible attr_field.to_sym
      end

      object.belongs_tos.each do |h|
        object_model_name = h.source_name.attribute
        object_klass_name = "#{object_model_name}#{object.user.id}".classify
        belongs_to object_klass_name.underscore.to_sym, inverse_of: klass_name.underscore.to_sym, inverse_class_name: klass_name
        attr_field = object_klass_name.underscore + "_id"
        attr_accessible attr_field.to_sym
      end

      object.habtms.each do |h|
        object_model_name = h.source_name.attribute
        object_klass_name = "#{object_model_name}#{object.user.id}".classify
        has_and_belongs_to_many object_klass_name.tableize.to_sym, inverse_of: klass_name.underscore.to_sym, inverse_class_name: klass_name
        attr_field = object_klass_name.underscore + "_ids"
        attr_accessible attr_field.to_sym
      end

      #Validates Presence
      object.source_attributes.each do |s|
        validates_presence_of s.field_name.attribute.to_sym, message: s.fetch_message('presence') if s.validate_presence_of 'presence'
      end

      #Validates Length
      object.source_attributes.each do |source_attribute|
        validates_length_of source_attribute.field_name.attribute.to_sym, minimum: source_attribute.fetch_min, maximum: source_attribute.fetch_max if source_attribute.validate_presence_of 'length'
      end

      #Validates Uniqueness
      object.source_attributes.each do |s|
        validates_uniqueness_of s.field_name.attribute.to_sym if s.validate_presence_of 'uniqueness'
      end

      def self.collection_name
        self.name.tableize
      end
    end

    Object.send(:remove_const, klass_name.to_sym) unless klass_name.not_loaded
    Object.const_set klass_name, klass
  end
end
